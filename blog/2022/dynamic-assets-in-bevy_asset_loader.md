---
title: "Dynamic assets"
date: 2022-03-01
category: code
summary: "Summary"
hide: true
tags:
- gamedev
- rust
- bevy
---

*One of my favorite Bevy projects at the moment is my plugin [`bevy_asset_loader`][project] ([repository][repo]). Its goal is to minimize boilerplate for asset handling while improving code readability and maintainability for games with a lot of assets. I wrote about the motivation and basic idea of the plugin in [a previous blog post][asset_handling_post]. Most of the future functionality mentioned in the post is now implemented. The biggest feature added to [`bevy_asset_loader`][project] since the last blog post was not discussed though. That's what this post is all about.*

## The idea

In the beginning of [`bevy_asset_loader`][project], all the information needed to load a certain asset was given at compile time. Things like the file path, type information (load it as a standard material plz), or tile sizes for a sprite sheet are passed in derive macro attributes.

```rust
#[derive(AssetCollection)]
pub struct TextureAssets {
    #[asset(path = "textures/player.png")]
    pub player: Handle<Image>,
    #[asset(texture_atlas(tile_size_x = 64., tile_size_y = 32., columns = 6, rows = 1))]
    #[asset(path = "textures/dog_sprite_sheet.png")]
    pub dog: Handle<TextureAtlas>,
}
```
_Giving all asset configuration at compile time._

At compile time the derive macro will "hardcode" the file paths and other configuration in the generated code to load the assets. The information directly on the asset collection structs is convenient and reads very well. But there is an issue with this.

 If different people (or even different teams) take care of assets and coding, the information seems to be at the wrong place. Tile sizes for a sprite sheet might change with updates on the sprite sheet. Changing this configuration feels like it should happen outside the code. The configuration for an asset should be an asset itself.

## Dynamic assets

In some way, configuration and asset handle still need to be connected. I went for the simplest approach and use string keys to connect them. These keys need to be given in our asset collections as derive macro attributes. From now on I will call assets "dynamic" if they have a string key and no other hardcoded asset configuration like a file path.

```rust
#[derive(AssetCollection)]
pub struct TextureAssets {
    #[asset(key = "player")]
    pub player: Handle<Image>,
    #[asset(key = "dog")]
    pub dog: Handle<TextureAtlas>,
}
```
_An asset collection with "dynamic assets"._

At compile time, the file paths and texture atlas configuration are not known. The code generated by the `rust$AssetCollection` derive macro, uses the string key to grab all asset configuration at run time. [`bevy_asset_loader`][project] stores the key <-> asset configuration mapping in a resource. Users can either manage it manually and configure all used keys before the loading state, or load everything from ron files.

```rust
fn setup_system(
    mut asset_keys: ResMut<AssetKeys>,
) {
    asset_keys.register_asset(
        "player",
        DynamicAsset::File {
            path: "textures/player.png".to_owned(),
        },
    );
    asset_keys.register_asset(
        "dog",
        DynamicAsset::TextureAtlas {
            path: "textures/dog_sprite_sheet.png".to_owned(),
            tile_size_x: 64.,
            tile_size_y: 32.,
            columns: 6,
            rows: 1
        },
    );
}
```
_Manually registering the required asset keys to load the `rust$TextureAssets` asset collection._

Manual registration does not solve the original problem. The asset configuration is still a part of our code. This is why I think the main use case of dynamic assets is the possibility to load key <-> asset configuration mappings from `ron` files. If you enable the feature `rust$dynamic_assets`, the following file can be loaded by [`bevy_asset_loader`][project]. All asset keys will be automatically registered before dynamic assets are resolved.

```ron
({
    "player": File (
        path: "textures/player.png",
    ),
    "dog": TextureAtlas (
        path: "textures/dog_sprite_sheet.png",
        tile_size_x: 64.,
        tile_size_y: 32.,
        columns: 6,
        rows: 1
    ),
})
```
_File in `ron` notation containing asset keys and their configurations. By default, the file ending should be `.assets`._

With such a `ron` file, all configurations regarding your assets are assets themselves. A little setup is required to tell [`bevy_asset_loader`][project] which `ron` files should be loaded before which loading state.

```rust
fn main() {
    let mut app = App::new();
    app.add_plugins(DefaultPlugins);

    AssetLoader::new(MyStates::AssetLoading)
        .continue_to_state(MyStates::Next)
        .with_asset_collection_file("dynamic_asset_ron.assets")
        .with_collection::<TextureAssets>()
        .build(&mut app);
    app.run();
}
```
_Setup to load asset configurations from a `ron` file._

That's it. We now moved all asset configuration out of our code.

## Extras

I showed examples for loading a texture atlas and loading "simple" assets from files dynamically. In the same way you can also load an image directly as a `rust$StandardMaterial` and load a complete directory as a vector of untyped handles. You can even have optional fields on asset collections now. If the key cannot be resoled at run time, the field will be `rust$None`.

In some cases, it is required to give more info at compile time than just the key. For example, when loading a directory, the field needs to be additionally annotated with `rust$#[asset(folder)]`. In the same way, optional fields need `rust$#[asset(optional)]`. This is a limitation I have not been able to lift, because I need to handle return types that are different from `rust$Handle<T>` separately at compile time.

## More to come

but what?...

---

Thank you for reading! If you have any feedback, questions, or comments, you can find me on Twitter ([@nikl_me][twitter]) or on the [Bevy Discord server][bevy_discord] (@Nikl).

[repo]: https://github.com/NiklasEi/bevy_asset_loader
[project]: /projects/bevy_asset_loader/
[bevy]: https://bevyengine.org/
[twitter]: https://twitter.com/nikl_me
[bevy_discord]: https://discord.gg/bevy
[asset_handling_post]: /blog/2021/asset-handling-in-bevy-apps
